// Generated by CoffeeScript 1.8.0
(function() {
  var $, Backbone, async, bootstrap, channelProtocol, env, helpers, init, initCore, initLogger, initViews, initWebsocket, lweb, queryProtocol, settings, waitDocument, _,
    __slice = [].slice;

  bootstrap = require('bootstrap-browserify');

  Backbone = require('backbone4000');

  helpers = require('helpers');

  async = require('async');

  _ = window._ = require('underscore');

  $ = require('jquery-browserify');

  lweb = require('lweb3/transports/client/websocket');

  queryProtocol = require('lweb3/protocols/query');

  channelProtocol = require('lweb3/protocols/channel');

  settings = {
    websockethost: window.location.protocol + "//" + window.location.host
  };

  env = {
    settings: settings
  };

  window.env = env;

  waitDocument = function(env, callback) {
    return $(document).ready(function() {
      return callback();
    });
  };

  initLogger = function(env, callback) {
    env.log = function() {
      var data, json, taglist, tags, text;
      text = arguments[0], data = arguments[1], taglist = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
      tags = {};
      _.map(taglist, function(tag) {
        return tags[tag] = true;
      });
      if (tags.error) {
        text = text.red;
      }
      if (tags.error && _.keys(data).length) {
        json = " " + JSON.stringify(msg.data);
      } else {
        json = "";
      }
      return console.log("-> " + _.keys(tags).join(', ') + " " + text + json);
    };
    env.wrapInit = function(text, f) {
      return function(callback) {
        console.log('>', text);
        return f(env, function(err, data) {
          console.log('<', text, "DONE");
          return callback(err, data);
        });
      };
    };
    env.log('logger', {}, 'init', 'ok');
    return callback();
  };

  initCore = function(env, callback) {
    env.lweb = new lweb.webSocketClient({
      host: env.settings.websockethost,
      verbose: false
    });
    env.lweb.addProtocol(new queryProtocol.client({
      verbose: true
    }));
    env.lweb.addProtocol(new channelProtocol.client({
      verbose: true
    }));
    return callback();
  };

  initWebsocket = function(env, callback) {
    if (env.lweb.attributes.socketIo.socket.connected) {
      return callback();
    } else {
      return env.lweb.on('connect', callback);
    }
  };

  initViews = function(env, callback) {
    return callback();
  };

  init = function(env, callback) {
    return initLogger(env, function() {
      return async.auto({
        documentready: (function(callback) {
          return waitDocument(env, callback);
        }),
        views: [
          'documentready', function(callback) {
            return initViews(env, callback);
          }
        ],
        core: ['views', env.wrapInit("Initializing core...", initCore)],
        websocket: ['core', env.wrapInit("Initializing connection...", initWebsocket)]
      });
    });
  };

  init(env, function(err, data) {
    if (err) {
      env.log('clientside init failed', {}, 'init', 'fail', 'error');
      return;
    }
    return env.log('clientside ready', {}, 'init', 'ok', 'completed');
  });

}).call(this);
