// Generated by CoffeeScript 1.8.0
(function() {
  var Bacbone, async, channelProtocol, collections, colors, dropPrivileges, env, helpers, init, initIrc, initLweb, initModels, initRibcage, initRoutes, lweb, queryProtocol, ribcage, settings, _;

  colors = require('colors');

  async = require('async');

  _ = require('underscore');

  helpers = require('helpers');

  Bacbone = require('backbone4000');

  collections = require('collections/serverside');

  lweb = require('lweb3/transports/server/websocket');

  queryProtocol = require('lweb3/protocols/query');

  channelProtocol = require('lweb3/protocols/channel');

  ribcage = require('ribcage');

  settings = {
    production: false,
    module: {
      db: {
        name: 'presence',
        host: 'localhost',
        port: 27017
      },
      express: {
        port: 3005,
        "static": __dirname + '/static',
        views: __dirname + '/ejs',
        cookiesecret: helpers.rndid(30)
      }
    },
    irc: {
      nick: 'mamaPresence',
      pass: false,
      channel: '#mamapresence'
    },
    user: false
  };

  env = {
    settings: settings
  };

  initRibcage = function(env, callback) {
    var connectmongodb, ejslocals, express;
    express = require('express');
    ejslocals = require('ejs-locals');
    connectmongodb = require('connect-mongodb');
    env.settings.module.express.configure = function() {
      env.app.engine('ejs', ejslocals);
      env.app.set('view engine', 'ejs');
      env.app.set('views', env.settings.module.express.views);
      env.app.use(express.compress());
      env.app.use(express.favicon());
      env.app.use(express.bodyParser());
      env.app.set('etag', true);
      env.app.set('x-powered-by', false);
      env.app.use(env.app.router);
      env.app.use(express["static"](env.settings.module.express["static"]));
      return env.app.use((function(_this) {
        return function(err, req, res, next) {
          throw err;
          env.log('web request error', {
            error: util.inspect(err)
          }, 'error', 'http');
          console.error(util.inspect(err));
          if (!env.settings.production) {
            return res.send(500, util.inspect(err));
          } else {
            return res.send(500, 'error 500');
          }
        };
      })(this));
    };
    env.logres = function(name, callback) {
      return function(err, data) {
        var logStr;
        if (err) {
          env.log(name + ' (' + colors.red(err) + ")", {
            error: err
          }, 'init', 'fail');
        } else {
          if ((data != null ? data.constructor : void 0) !== String) {
            logStr = "...";
          } else {
            logStr = " (" + colors.green(data) + ")";
          }
          env.log(name + logStr, {}, 'init', 'ok');
        }
        return callback(err, data);
      };
    };
    return ribcage.init(env, callback);
  };

  initIrc = function(env, callback) {
    var client, irc;
    if (!env.settings.irc.enabled) {
      return callback();
    }
    irc = require('irc');
    client = env.ircclient = new irc.Client(env.settings.irc.server, env.settings.irc.nick, {
      channels: [env.settings.irc.channel]
    });
    return client.addListener('join', function() {
      var pass;
      if (pass = env.settings.irc.nickpass) {
        client.say('nickserv', "identify " + pass);
      }
      client.say(env.settings.irc.channel, "My body (v." + env.version + ") is ready");
      env.lweb.channel('chat-global').subscribe(function(msg) {
        return client.say(env.settings.irc.channel, "<" + msg.fromName + "> " + msg.msg);
      });
      return callback();
    });
  };

  initLweb = function(env, callback) {
    env.lweb = new lweb.webSocketServer({
      http: env.http,
      verbose: false
    });
    env.lweb.addProtocol(new queryProtocol.serverServer({
      verbose: false
    }));
    env.lweb.addProtocol(new channelProtocol.serverServer({
      verbose: false
    }));
    return callback();
  };

  initModels = function(env, callback) {
    return true;
  };

  initRoutes = function(env, callback) {
    var logreq;
    logreq = function(req, res, next) {
      var forwarded, host;
      host = req.socket.remoteAddress;
      if (host === "127.0.0.1") {
        if (forwarded = req.headers['x-forwarded-for']) {
          host = forwarded;
        }
      }
      env.log(host + " " + req.method + " " + req.originalUrl, {
        level: 2,
        ip: host,
        headers: req.headers,
        method: req.method
      }, 'http', req.method, host);
      return next();
    };
    env.app.use(function(req, res, next) {
      res.header("Access-Control-Allow-Origin", "*");
      res.header("Access-Control-Allow-Headers", "Origin, X-Requested-With, Content-Type, Accept");
      return next();
    });
    env.app.get('*', logreq);
    env.app.post('*', logreq);
    env.app.get('/', function(req, res) {
      return res.render('index', {
        title: 'mama - presence',
        version: env.version,
        production: env.settings.production
      });
    });
    return callback();
  };

  dropPrivileges = function(env, callback) {
    var err, group, user;
    if (!env.settings.user) {
      return callback(null, colors.magenta("WARNING: staying at uid " + (process.getuid())));
    }
    user = env.settings.user;
    group = env.settings.group || user;
    try {
      process.initgroups(user, group);
      process.setgid(group);
      process.setuid(user);
    } catch (_error) {
      err = _error;
      if (err.code === 'EPERM') {
        return callback(null, colors.magenta("WARNING: permission denied"));
      } else {
        return callback(err);
      }
    }
    return callback(null, "dropped to " + user + "/" + group);
  };

  initLweb = function(env, callback) {
    env.lweb = new lweb.webSocketServer({
      http: env.http,
      verbose: false
    });
    env.lweb.addProtocol(new queryProtocol.serverServer({
      verbose: false
    }));
    env.lweb.addProtocol(new channelProtocol.serverServer({
      verbose: false
    }));
    return callback();
  };

  init = function(env, callback) {
    return async.auto({
      ribcage: function(callback) {
        return initRibcage(env, callback);
      },
      irc: [
        'ribcage', function(callback) {
          return initIrc(env, env.logres('irc', callback));
        }
      ],
      privileges: [
        'ribcage', function(callback) {
          return dropPrivileges(env, env.logres('drop user', callback));
        }
      ],
      routes: [
        'ribcage', function(callback) {
          return initRoutes(env, env.logres('routes', callback));
        }
      ],
      lweb: [
        'ribcage', function(callback) {
          return initLweb(env, env.logres('lweb', callback));
        }
      ]
    }, callback);
  };

  init(env, function(err, data) {
    if (err) {
      env.log(colors.red('my body is not ready, exiting'), {}, 'init', 'error');
      return process.exit(15);
    } else {
      env.log('application running', {}, 'init', 'completed');
      return console.log(colors.green('\n\n\t\t\tMy body is ready\n\n'));
    }
  });

}).call(this);
