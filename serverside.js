// Generated by CoffeeScript 1.8.0
(function() {
  var Bacbone, async, channelProtocol, collections, colors, dropPrivileges, env, helpers, init, initIgnoreList, initIrc, initLweb, initModels, initReader, initRibcage, initRoutes, initWriter, lwebTcp, lwebWs, queryProtocol, ribcage, settings, _;

  colors = require('colors');

  async = require('async');

  _ = require('underscore');

  helpers = require('helpers');

  Bacbone = require('backbone4000');

  collections = require('collections/serverside');

  lwebTcp = require('lweb3/transports/server/tcp');

  lwebWs = require('lweb3/transports/server/websocket');

  queryProtocol = require('lweb3/protocols/query');

  channelProtocol = require('lweb3/protocols/channel');

  ribcage = require('ribcage');

  settings = {
    production: false,
    module: {
      db: {
        name: 'presence',
        host: 'localhost',
        port: 27017
      },
      express: {
        port: 3005,
        "static": __dirname + '/static',
        views: __dirname + '/ejs',
        cookiesecret: helpers.rndid(30)
      }
    },
    probePort: 3131,
    irc: {
      nick: 'mamaPresence',
      pass: false,
      channel: '#mamapresence'
    },
    user: false
  };

  env = {
    settings: settings
  };

  initRibcage = function(env, callback) {
    var connectmongodb, ejslocals, express;
    express = require('express');
    ejslocals = require('ejs-locals');
    connectmongodb = require('connect-mongodb');
    env.settings.module.express.configure = function() {
      env.app.engine('ejs', ejslocals);
      env.app.set('view engine', 'ejs');
      env.app.set('views', env.settings.module.express.views);
      env.app.use(express.compress());
      env.app.use(express.favicon());
      env.app.use(express.bodyParser());
      env.app.set('etag', true);
      env.app.set('x-powered-by', false);
      env.app.use(env.app.router);
      env.app.use(express["static"](env.settings.module.express["static"]));
      return env.app.use((function(_this) {
        return function(err, req, res, next) {
          throw err;
          env.log('web request error', {
            error: util.inspect(err)
          }, 'error', 'http');
          console.error(util.inspect(err));
          if (!env.settings.production) {
            return res.send(500, util.inspect(err));
          } else {
            return res.send(500, 'error 500');
          }
        };
      })(this));
    };
    env.logres = function(name, callback) {
      return function(err, data) {
        var logStr;
        if (err) {
          env.log(name + ' (' + colors.red(err) + ")", {
            error: err
          }, 'init', 'fail');
        } else {
          if ((data != null ? data.constructor : void 0) !== String) {
            logStr = "...";
          } else {
            logStr = " (" + colors.green(data) + ")";
          }
          env.log(name + logStr, {}, 'init', 'ok');
        }
        return callback(err, data);
      };
    };
    return ribcage.init(env, callback);
  };

  initIrc = function(env, callback) {
    var client, irc;
    if (!env.settings.irc.enabled) {
      return callback();
    }
    irc = require('irc');
    client = env.ircclient = new irc.Client(env.settings.irc.server, env.settings.irc.nick, {
      channels: [env.settings.irc.channel]
    });
    return client.addListener('join', function() {
      var pass;
      if (pass = env.settings.irc.nickpass) {
        client.say('nickserv', "identify " + pass);
      }
      client.say(env.settings.irc.channel, "My body (v." + env.version + ") is ready");
      return callback();
    });
  };

  initLweb = function(env, callback) {
    env.lweb = new lwebWs.webSocketServer({
      http: env.http,
      verbose: false
    });
    env.lweb.addProtocol(new queryProtocol.serverServer({
      verbose: false
    }));
    env.lweb.addProtocol(new channelProtocol.serverServer({
      verbose: false
    }));
    return callback();
  };

  initModels = function(env, callback) {
    return callback();
  };

  initRoutes = function(env, callback) {
    var logreq;
    logreq = function(req, res, next) {
      var forwarded, host;
      host = req.socket.remoteAddress;
      if (host === "127.0.0.1") {
        if (forwarded = req.headers['x-forwarded-for']) {
          host = forwarded;
        }
      }
      env.log(host + " " + req.method + " " + req.originalUrl, {
        level: 2,
        ip: host,
        headers: req.headers,
        method: req.method
      }, 'http', req.method, host);
      return next();
    };
    env.app.use(function(req, res, next) {
      res.header("Access-Control-Allow-Origin", "*");
      res.header("Access-Control-Allow-Headers", "Origin, X-Requested-With, Content-Type, Accept");
      return next();
    });
    env.app.get('*', logreq);
    env.app.post('*', logreq);
    env.app.get('/', function(req, res) {
      return res.render('index', {
        title: 'mama - presence',
        version: env.version,
        production: env.settings.production
      });
    });
    return callback();
  };

  dropPrivileges = function(env, callback) {
    var err, group, user;
    if (!env.settings.user) {
      return callback(null, colors.magenta("WARNING: staying at uid " + (process.getuid())));
    }
    user = env.settings.user;
    group = env.settings.group || user;
    try {
      process.initgroups(user, group);
      process.setgid(group);
      process.setuid(user);
    } catch (_error) {
      err = _error;
      if (err.code === 'EPERM') {
        return callback(null, colors.magenta("WARNING: permission denied"));
      } else {
        return callback(err);
      }
    }
    return callback(null, "dropped to " + user + "/" + group);
  };

  initLweb = function(env, callback) {
    env.lweb = new lwebWs.webSocketServer({
      http: env.http,
      verbose: false
    });
    env.lweb.addProtocol(new queryProtocol.serverServer({
      verbose: false
    }));
    env.lweb.addProtocol(new channelProtocol.serverServer({
      verbose: true
    }));
    return callback();
  };

  initIgnoreList = function(env, callback) {};

  initReader = function(env, callback) {
    var packet;
    env.probeListener = new lwebTcp.tcpServer({
      port: settings.probePort,
      name: 'probe',
      verbose: true
    });
    packet = function(state, mac) {
      if (state === void 0 || !mac) {
        return;
      }
      if (env.ignore[mac]) {
        return;
      }
      console.log('mac', mac, 'state', state);
      return env.lweb.channel('macs').broadcast({
        mac: mac,
        state: state
      });
    };
    env.probeListener.on('connect', function(channel) {
      return channel.subscribe(true, function(msg) {
        return _.map(msg.split('\n'), function(line) {
          var mac, state, _ref;
          if (!line) {
            return;
          }
          _ref = line.split(' '), state = _ref[0], mac = _ref[1];
          return packet(Number(state), mac);
        });
      });
    });
    return callback(null, "port " + settings.probePort);
  };

  initModels = function(env, callback) {
    env.ignore = {};
    env.db.log = new collections.MongoCollection({
      collection: 'log',
      db: env.db
    });
    env.logon = env.db.log.defineModel('on', {});
    env.logoff = env.db.log.defineModel('off', {});
    env.db.ignore = new collections.MongoCollection({
      collection: 'ignore',
      db: env.db
    });
    return env.db.ignore.find({}, {}, (function(err, entry) {
      return env.ignore[entry.mac] = true;
    }), function(err, data) {
      console.log('ignoring', env.ignore);
      return callback(null, true);
    });
  };

  initWriter = function(env, callback) {
    return callback(null, true);
  };

  init = function(env, callback) {
    return async.auto({
      ribcage: function(callback) {
        return initRibcage(env, callback);
      },
      irc: [
        'ribcage', function(callback) {
          return initIrc(env, env.logres('irc', callback));
        }
      ],
      privileges: [
        'ribcage', function(callback) {
          return dropPrivileges(env, env.logres('drop user', callback));
        }
      ],
      routes: [
        'ribcage', function(callback) {
          return initRoutes(env, env.logres('routes', callback));
        }
      ],
      lweb: [
        'ribcage', function(callback) {
          return initLweb(env, env.logres('lweb', callback));
        }
      ],
      models: [
        'ribcage', function(callback) {
          return initModels(env, env.logres('models', callback));
        }
      ],
      reader: [
        'models', function(callback) {
          return initReader(env, env.logres('reader', callback));
        }
      ],
      writer: [
        'ribcage', 'reader', function(callback) {
          return initWriter(env, env.logres('writer', callback));
        }
      ]
    }, callback);
  };

  init(env, function(err, data) {
    if (err) {
      env.log(colors.red('my body is not ready, exiting'), {}, 'init', 'error');
      return process.exit(15);
    } else {
      env.log('application running', {}, 'init', 'completed');
      return console.log(colors.green('\n\n\t\t\tMy body is ready\n\n'));
    }
  });

}).call(this);
